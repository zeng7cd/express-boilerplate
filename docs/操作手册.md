# Express TypeScript Boilerplate 操作手册

> 本手册详细介绍项目的核心功能、装饰器系统、中间件、路由配置以及最佳实践和注意事项。

## 目录

- [1. 项目概述](#1-项目概述)
- [2. 装饰器系统](#2-装饰器系统)
- [3. 路由系统](#3-路由系统)
- [4. 中间件系统](#4-中间件系统)
- [5. 认证与授权](#5-认证与授权)
- [6. 数据验证](#6-数据验证)
- [7. 缓存系统](#7-缓存系统)
- [8. 事件系统](#8-事件系统)
- [9. Repository 模式](#9-repository-模式)
- [10. 错误处理](#10-错误处理)
- [11. 最佳实践](#11-最佳实践)
- [12. 注意事项](#12-注意事项)

---

## 1. 项目概述

### 1.1 技术栈

- **运行时**: Node.js 18+
- **框架**: Express 5.x
- **语言**: TypeScript 5.x
- **数据库**: MySQL 8+ + Drizzle ORM
- **缓存**: Redis + ioredis
- **认证**: JWT (jsonwebtoken)
- **日志**: Pino
- **验证**: Zod
- **测试**: Vitest

### 1.2 核心特性

- 基于装饰器的路由系统
- 类型安全的事件总线
- Repository 数据访问模式
- 自动错误处理
- 性能监控
- 缓存预热
- 优雅关闭

---

## 2. 装饰器系统

### 2.1 控制器装饰器 `@Controller`

**作用**: 定义一个控制器类，并指定路由前缀。

**语法**:

```typescript
@Controller(prefix: string, options?: {
  middlewares?: RequestHandler[];
  description?: string;
  isSystemRoute?: boolean;
})
```

**参数说明**:

- `prefix`: 路由前缀，例如 `/users`
- `middlewares`: 应用于整个控制器的中间件数组（可选）
- `description`: 控制器描述（可选）
- `isSystemRoute`: 是否为系统路由，不添加 API 前缀（可选，默认 false）

**示例**:

```typescript
import { Controller } from '@/core/router';

@Controller('/users', {
  description: '用户管理接口',
})
export class UserController {
  // 路由方法...
}
```

**注意事项**:

- 控制器类必须导出，否则无法被自动注册
- 路由前缀会自动添加 API 前缀（默认 `/api`），除非设置 `isSystemRoute: true`
- 控制器级别的中间件会应用到所有路由方法

---

### 2.2 HTTP 方法装饰器

**可用装饰器**: `@Get`, `@Post`, `@Put`, `@Patch`, `@Delete`, `@Options`, `@Head`

**语法**:

```typescript
@Get(path: string, options?: {
  middlewares?: RequestHandler[];
  description?: string;
})
```

**参数说明**:

- `path`: 路由路径，例如 `/` 或 `/:id`
- `middlewares`: 应用于该路由的中间件数组（可选）
- `description`: 路由描述（可选）

**示例**:

```typescript
import { Controller, Get, Post, Put, Delete } from '@/core/router';
import type { Request, Response } from 'express';

@Controller('/users')
export class UserController {
  @Get('/', { description: '获取用户列表' })
  async list(req: Request, res: Response): Promise<void> {
    res.json({ success: true, data: [] });
  }

  @Get('/:id', { description: '获取用户详情' })
  async get(req: Request, res: Response): Promise<void> {
    const { id } = req.params;
    res.json({ success: true, data: { id } });
  }

  @Post('/', { description: '创建用户' })
  async create(req: Request, res: Response): Promise<void> {
    res.status(201).json({ success: true, data: req.body });
  }

  @Put('/:id', { description: '更新用户' })
  async update(req: Request, res: Response): Promise<void> {
    const { id } = req.params;
    res.json({ success: true, data: { id, ...req.body } });
  }

  @Delete('/:id', { description: '删除用户' })
  async delete(req: Request, res: Response): Promise<void> {
    const { id } = req.params;
    res.json({ success: true, message: 'User deleted' });
  }
}
```

**注意事项**:

- 路由方法必须是 `async` 函数或返回 Promise
- 异常会被自动捕获并传递给错误处理中间件
- 路径参数使用 Express 标准语法（`:paramName`）

---

### 2.3 认证装饰器 `@Auth`

**作用**: 为路由添加 JWT 认证保护。

**语法**:

```typescript
@Auth()
```

**示例**:

```typescript
import { Controller, Get, Auth } from '@/core/router';

@Controller('/users')
export class UserController {
  @Auth()  // 需要认证
  @Get('/')
  async list(req: Request, res: Response): Promise<void> {
    // req.user 包含已认证用户信息
    const userId = req.user?.sub;
    res.json({ success: true, data: [] });
  }
}
```

**认证后可用的用户信息** (`req.user`):

```typescript
interface JWTPayload {
  sub: string;           // 用户 ID
  email: string;         // 用户邮箱
  username: string;      // 用户名
  roles: string[];       // 角色列表
  permissions: string[]; // 权限列表
  iat: number;          // 签发时间
  exp: number;          // 过期时间
}
```

**注意事项**:

- 必须在请求头中携带 `Authorization: Bearer <token>`
- Token 过期或无效会返回 401 错误
- Token 黑名单会自动检查（登出后的 token）
- 可以与 `@Public()` 装饰器配合使用标记公开路由

---

### 2.4 验证装饰器 `@Validate`

**作用**: 使用 Zod schema 自动验证请求数据。

**语法**:

```typescript
@Validate(schema: z.ZodTypeAny)
```

**示例**:

```typescript
import { Controller, Post, Validate } from '@/core/router';
import { z } from 'zod';

// 定义验证 schema
const createUserSchema = z.object({
  body: z.object({
    email: z.string().email('Invalid email format'),
    username: z.string().min(3, 'Username must be at least 3 characters'),
    password: z.string().min(8, 'Password must be at least 8 characters'),
  }),
});

@Controller('/users')
export class UserController {
  @Validate(createUserSchema)
  @Post('/')
  async create(req: Request, res: Response): Promise<void> {
    // 数据已经过验证，可以安全使用
    const { email, username, password } = req.body;
    res.status(201).json({ success: true });
  }
}
```

**验证不同部分的数据**:

```typescript
// 验证 body、query 和 params
const schema = z.object({
  body: z.object({
    name: z.string(),
  }),
  query: z.object({
    page: z.string().optional(),
  }),
  params: z.object({
    id: z.string(),
  }),
});
```

**注意事项**:

- Schema 必须包含 `body`、`query` 或 `params` 字段
- 验证失败会自动返回 400 错误，包含详细的错误信息
- 建议将 schema 定义在单独的文件中（如 `schemas/` 目录）

---

### 2.5 限流装饰器 `@RateLimit`

**作用**: 为特定路由配置独立的限流策略。

**语法**:

```typescript
@RateLimit(options: {
  windowMs: number;  // 时间窗口（毫秒）
  max: number;       // 最大请求数
  message?: string;  // 错误消息（可选）
})
```

**示例**:

```typescript
import { Controller, Post, RateLimit } from '@/core/router';

@Controller('/auth')
export class AuthController {
  @RateLimit({
    windowMs: 15 * 60 * 1000, // 15 分钟
    max: 5,                    // 最多 5 次请求
    message: 'Too many login attempts, please try again later',
  })
  @Post('/login')
  async login(req: Request, res: Response): Promise<void> {
    // 登录逻辑
  }

  @RateLimit({
    windowMs: 60 * 60 * 1000, // 1 小时
    max: 3,                    // 最多 3 次请求
    message: 'Too many registration attempts',
  })
  @Post('/register')
  async register(req: Request, res: Response): Promise<void> {
    // 注册逻辑
  }
}
```

**常见限流配置**:

- **登录接口**: 15 分钟 5 次
- **注册接口**: 1 小时 3 次
- **敏感操作**: 1 分钟 10 次
- **普通 API**: 15 分钟 100 次

**注意事项**:

- 限流基于客户端 IP 地址
- 超过限制会返回 429 错误
- 响应头会包含限流信息（`X-RateLimit-*`）
- 建议为所有敏感接口配置限流

---

### 2.6 缓存装饰器 `@Cacheable` 和 `@CacheEvict`

**作用**: 自动缓存方法返回结果或清除缓存。

#### 2.6.1 `@Cacheable` - 缓存结果

**语法**:

```typescript
@Cacheable(options: {
  key: string;                          // 缓存键前缀
  ttl?: number;                         // 过期时间（秒），默认 300
  condition?: (result: any) => boolean; // 缓存条件
  includeArgs?: boolean;                // 是否包含参数，默认 true
})
```

**示例**:

```typescript
import { Cacheable } from '@/shared/decorators/cache.decorator';

export class UserRepository extends BaseRepository<typeof users> {
  @Cacheable({ key: 'user:id', ttl: 600 })
  async findById(id: string) {
    return this.db.query.users.findFirst({
      where: eq(users.id, id),
    });
  }

  @Cacheable({
    key: 'users:list',
    ttl: 300,
    condition: (result) => result.length > 0, // 只缓存非空结果
  })
  async findAll() {
    return this.db.query.users.findMany();
  }
}
```

#### 2.6.2 `@CacheEvict` - 清除缓存

**语法**:

```typescript
@CacheEvict(options: {
  key: string;          // 缓存键前缀
  includeArgs?: boolean; // 是否包含参数，默认 true
})
```

**示例**:

```typescript
import { CacheEvict } from '@/shared/decorators/cache.decorator';

export class UserRepository extends BaseRepository<typeof users> {
  @CacheEvict({ key: 'user:id' })
  async update(id: string, data: any) {
    return this.db.update(users)
      .set(data)
      .where(eq(users.id, id));
  }

  @CacheEvict({ key: 'users:list', includeArgs: false })
  async create(data: any) {
    return this.db.insert(users).values(data);
  }
}
```

**注意事项**:

- 缓存键会自动包含方法参数（除非设置 `includeArgs: false`）
- 缓存失败不会影响方法执行
- 建议为频繁查询的数据添加缓存
- 更新/删除操作要记得清除相关缓存

---

## 3. 路由系统

### 3.1 路由注册流程

项目使用自动路由注册机制：

1. **导入控制器**: 在 `src/controllers.ts` 中导入所有控制器
2. **装饰器注册**: 装饰器会自动将控制器注册到全局注册表
3. **路由挂载**: 应用启动时自动挂载所有路由

**控制器导入示例** (`src/controllers.ts`):

```typescript
// 认证模块
export * from './modules/auth/controllers/auth.controller';

// 用户模块
export * from './modules/users/controllers/user.controller';

// 角色模块
export * from './modules/roles/controllers/role.controller';
```

### 3.2 路由配置

路由配置在 `src/core/config/routes.ts` 中：

```typescript
import { registerRoutes, printRouteConfiguration } from '@/core/router/registry';

export default function setupRoutes(app: Application): void {
  // 注册所有装饰器路由
  const result = registerRoutes(app);

  // 打印路由配置
  printRouteConfiguration(result);
}
```

### 3.3 完整的控制器示例

```typescript
import { Controller, Get, Post, Put, Delete, Auth, Validate, RateLimit } from '@/core/router';
import type { Request, Response } from 'express';
import { userRepository } from '../repositories/user.repository';
import { createUserSchema, updateUserSchema } from '../schemas';

@Controller('/users', {
  description: '用户管理接口',
})
export class UserController {
  /**
   * 获取用户列表（分页）
   */
  @Auth()
  @Get('/', { description: '获取用户列表' })
  async list(req: Request, res: Response): Promise<void> {
    const { page = 1, limit = 20 } = req.query;

    const result = await userRepository.findPaginated({
      page: Number(page),
      limit: Number(limit),
    });

    res.json({
      success: true,
      data: result.data,
      meta: result.meta,
    });
  }

  /**
   * 获取用户详情
   */
  @Auth()
  @Get('/:id', { description: '获取用户详情' })
  async get(req: Request, res: Response): Promise<void> {
    const { id } = req.params;
    const user = await userRepository.findById(id);

    if (!user) {
      res.status(404).json({
        success: false,
        message: 'User not found',
      });
      return;
    }

    res.json({ success: true, data: user });
  }

  /**
   * 创建用户
   */
  @Auth()
  @RateLimit({ windowMs: 60000, max: 10 })
  @Validate(createUserSchema)
  @Post('/', { description: '创建用户' })
  async create(req: Request, res: Response): Promise<void> {
    const user = await userRepository.create(req.body);
    res.status(201).json({ success: true, data: user });
  }

  /**
   * 更新用户
   */
  @Auth()
  @Validate(updateUserSchema)
  @Put('/:id', { description: '更新用户' })
  async update(req: Request, res: Response): Promise<void> {
    const { id } = req.params;
    const user = await userRepository.update(id, req.body);
    res.json({ success: true, data: user });
  }

  /**
   * 删除用户（软删除）
   */
  @Auth()
  @Delete('/:id', { description: '删除用户' })
  async delete(req: Request, res: Response): Promise<void> {
    const { id } = req.params;
    await userRepository.softDelete(id);
    res.json({ success: true, message: 'User deleted' });
  }
}
```

---

## 4. 中间件系统

### 4.1 全局中间件

全局中间件在 `src/server.ts` 中配置，按顺序执行：

```typescript
// 1. Request ID（必须最先）
app.use(requestIdMiddleware);

// 2. Request Context
app.use(requestContextMiddleware);

// 3. Performance Monitoring
app.use(performanceMonitoring);

// 4. Request Logging
app.use(requestLogger);

// 5. Security Headers
app.use(securityHeaders);

// 6. Compression
app.use(compression());

// 7. Body Parsing
app.use(express.json({ limit: '10mb' }));
app.use(express.urlencoded({ extended: true, limit: '10mb' }));

// 8. CORS
app.use(cors({ origin: env.CORS_ORIGIN, credentials: true }));

// 9. Helmet (Security)
app.use(helmet());

// 10. Rate Limiting
app.use(rateLimiter);
```

### 4.2 核心中间件说明

#### 4.2.1 Request ID 中间件

**作用**: 为每个请求生成唯一 ID，用于日志追踪。

**实现**:

```typescript
export const requestIdMiddleware = (req: Request, res: Response, next: NextFunction) => {
  const requestId = req.headers['x-request-id'] as string || nanoid();
  req.id = requestId;
  res.setHeader('X-Request-ID', requestId);
  next();
};
```

**使用**:

```typescript
// 在日志中使用
import { getAppPinoLogger } from '@/core/logger/pino';

const logger = getAppPinoLogger();
logger.info({ requestId: req.id }, 'Processing request');
```

#### 4.2.2 认证中间件

**作用**: 验证 JWT token 并提取用户信息。

**实现位置**: `src/shared/middleware/auth.middleware.ts`

**使用方式**:

```typescript
// 方式 1: 使用装饰器（推荐）
@Auth()
@Get('/profile')
async getProfile(req: Request, res: Response) {
  const userId = req.user?.sub;
}

// 方式 2: 手动使用中间件
import { authenticateJWT } from '@/shared/middleware/auth.middleware';

@Get('/profile', { middlewares: [authenticateJWT] })
async getProfile(req: Request, res: Response) {
  const userId = req.user?.sub;
}
```

#### 4.2.3 权限验证中间件

**作用**: 验证用户是否具有特定权限或角色。

**使用示例**:

```typescript
import { requirePermissions, requireRoles } from '@/shared/middleware/auth.middleware';

@Controller('/admin')
export class AdminController {
  // 需要特定权限
  @Auth()
  @Get('/users', {
    middlewares: [requirePermissions(['user.read', 'user.write'])]
  })
  async manageUsers(req: Request, res: Response) {
    // 只有拥有 user.read 和 user.write 权限的用户才能访问
  }

  // 需要特定角色
  @Auth()
  @Get('/settings', {
    middlewares: [requireRoles(['admin', 'superadmin'])]
  })
  async settings(req: Request, res: Response) {
    // 只有 admin 或 superadmin 角色才能访问
  }
}
```

#### 4.2.4 验证中间件

**作用**: 使用 Zod schema 验证请求数据。

**实现位置**: `src/shared/middleware/validation.ts`

**使用方式**:

```typescript
// 方式 1: 使用装饰器（推荐）
@Validate(createUserSchema)
@Post('/users')
async create(req: Request, res: Response) {}

// 方式 2: 手动使用中间件
import { validate } from '@/shared/middleware/validation';

@Post('/users', { middlewares: [validate(createUserSchema)] })
async create(req: Request, res: Response) {}
```

#### 4.2.5 性能监控中间件

**作用**: 自动记录慢请求和响应时间。

**实现位置**: `src/shared/middleware/performance.middleware.ts`

**功能**:

- 记录每个请求的响应时间
- 自动标记慢请求（超过 1000ms）
- 在响应头中添加 `X-Response-Time`

#### 4.2.6 错误处理中间件

**作用**: 统一处理所有错误并返回标准格式。

**实现位置**: `src/shared/middleware/errorHandler.ts`

**处理的错误类型**:

1. 自定义应用异常 (`AppException`)
2. Zod 验证错误 (`ZodError`)
3. 数据库错误
4. 未知错误

**错误响应格式**:

```typescript
{
  success: false,
  code: 'ERROR_CODE',
  message: 'Error message',
  statusCode: 400,
  data: {
    details: [] // 仅在开发环境返回
  }
}
```

### 4.3 自定义中间件

**创建自定义中间件**:

```typescript
import type { Request, Response, NextFunction } from 'express';
import { getAppPinoLogger } from '@/core/logger/pino';

const logger = getAppPinoLogger();

export const customMiddleware = (req: Request, res: Response, next: NextFunction) => {
  // 前置处理
  logger.info('Before request processing');

  // 继续执行
  next();

  // 后置处理（可选）
  res.on('finish', () => {
    logger.info('After request processing');
  });
};
```

**使用自定义中间件**:

```typescript
// 应用到控制器
@Controller('/users', {
  middlewares: [customMiddleware],
})
export class UserController {}

// 应用到特定路由
@Get('/', {
  middlewares: [customMiddleware],
})
async list(req: Request, res: Response) {}
```

---

## 5. 认证与授权

### 5.1 JWT 认证流程

#### 5.1.1 用户注册

```typescript
POST /api/auth/register
Content-Type: application/json

{
  "email": "user@example.com",
  "username": "username",
  "password": "password123",
  "firstName": "John",
  "lastName": "Doe"
}
```

**响应**:

```json
{
  "success": true,
  "message": "User registered successfully",
  "data": {
    "id": "user_id",
    "email": "user@example.com",
    "username": "username"
  }
}
```

#### 5.1.2 用户登录

```typescript
POST /api/auth/login
Content-Type: application/json

{
  "email": "user@example.com",
  "password": "password123"
}
```

**响应**:

```json
{
  "success": true,
  "message": "Login successful",
  "data": {
    "user": {
      "id": "user_id",
      "email": "user@example.com",
      "username": "username",
      "roles": ["user"]
    },
    "tokens": {
      "accessToken": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
      "refreshToken": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
      "expiresIn": 3600
    }
  }
}
```

#### 5.1.3 刷新 Token

```typescript
POST /api/auth/refresh
Content-Type: application/json

{
  "refreshToken": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."
}
```

**响应**:

```json
{
  "success": true,
  "data": {
    "accessToken": "new_access_token",
    "expiresIn": 3600
  }
}
```

#### 5.1.4 用户登出

```typescript
POST /api/auth/logout
Authorization: Bearer <access_token>
```

**响应**:

```json
{
  "success": true,
  "message": "Logout successful"
}
```

### 5.2 JWT 服务使用

**位置**: `src/modules/auth/services/jwt.service.ts`

**主要方法**:

```typescript
import { jwtService } from '@/modules/auth/services/jwt.service';

// 生成访问令牌
const accessToken = jwtService.generateAccessToken({
  id: user.id,
  email: user.email,
  username: user.username,
  roles: ['user'],
  permissions: ['read'],
});

// 生成刷新令牌
const refreshToken = jwtService.generateRefreshToken(user.id);

// 验证访问令牌
const payload = jwtService.verifyAccessToken(token);

// 验证刷新令牌
const payload = jwtService.verifyRefreshToken(refreshToken);

// 解码令牌（不验证）
const decoded = jwtService.decodeToken(token);
```

### 5.3 Token 黑名单

**作用**: 管理已撤销的 token，防止登出后的 token 继续使用。

**位置**: `src/core/services/token-blacklist.service.ts`

**主要方法**:

```typescript
import { tokenBlacklistService } from '@/core/services/token-blacklist.service';

// 将 token 加入黑名单
await tokenBlacklistService.addToBlacklist(token, expiresInSeconds);

// 检查 token 是否在黑名单中
const isBlacklisted = await tokenBlacklistService.isBlacklisted(token);

// 撤销用户的所有 token
await tokenBlacklistService.blacklistUserTokens(userId, maxExpiry);

// 检查用户的所有 token 是否被撤销
const isUserBlacklisted = await tokenBlacklistService.isUserBlacklisted(userId);
```

### 5.4 权限和角色管理

#### 5.4.1 角色系统

项目使用 RBAC（基于角色的访问控制）模型：

- **用户 (User)** - 可以拥有多个角色
- **角色 (Role)** - 可以拥有多个权限
- **权限 (Permission)** - 具体的操作权限

**数据库关系**:

```
users ←→ user_roles ←→ roles ←→ role_permissions ←→ permissions
```

#### 5.4.2 检查权限

```typescript
import { requirePermissions, requireRoles } from '@/shared/middleware/auth.middleware';

@Controller('/api/admin')
export class AdminController {
  // 检查单个权限
  @Auth()
  @Get('/users', {
    middlewares: [requirePermissions(['user.read'])]
  })
  async listUsers(req: Request, res: Response) {}

  // 检查多个权限（需要全部满足）
  @Auth()
  @Post('/users', {
    middlewares: [requirePermissions(['user.create', 'user.write'])]
  })
  async createUser(req: Request, res: Response) {}

  // 检查角色（满足任一即可）
  @Auth()
  @Get('/settings', {
    middlewares: [requireRoles(['admin', 'superadmin'])]
  })
  async settings(req: Request, res: Response) {}
}
```

#### 5.4.3 在代码中检查权限

```typescript
@Auth()
@Get('/resource')
async getResource(req: Request, res: Response) {
  const user = req.user!;

  // 检查是否有特定权限
  if (!user.permissions.includes('resource.read')) {
    res.status(403).json({
      success: false,
      message: 'Insufficient permissions',
    });
    return;
  }

  // 检查是否有特定角色
  if (!user.roles.includes('admin')) {
    res.status(403).json({
      success: false,
      message: 'Admin role required',
    });
    return;
  }

  // 继续处理...
}
```

---

## 6. 数据验证

### 6.1 Zod Schema 定义

**推荐目录结构**:

```
src/modules/users/
  ├── schemas/
  │   ├── index.ts
  │   ├── user.schema.ts
  │   └── query.schema.ts
```

**Schema 示例** (`user.schema.ts`):

```typescript
import { z } from 'zod';

// 创建用户 Schema
export const createUserSchema = z.object({
  body: z.object({
    email: z.string().email('Invalid email format'),
    username: z.string()
      .min(3, 'Username must be at least 3 characters')
      .max(20, 'Username must not exceed 20 characters')
      .regex(/^[a-zA-Z0-9_]+$/, 'Username can only contain letters, numbers, and underscores'),
    password: z.string()
      .min(8, 'Password must be at least 8 characters')
      .regex(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)/, 'Password must contain uppercase, lowercase, and number'),
    firstName: z.string().min(1, 'First name is required').optional(),
    lastName: z.string().min(1, 'Last name is required').optional(),
  }),
});

// 更新用户 Schema
export const updateUserSchema = z.object({
  params: z.object({
    id: z.string().min(1, 'User ID is required'),
  }),
  body: z.object({
    email: z.string().email('Invalid email format').optional(),
    username: z.string().min(3).max(20).optional(),
    firstName: z.string().optional(),
    lastName: z.string().optional(),
    isActive: z.boolean().optional(),
  }),
});

// 查询参数 Schema
export const getUserSchema = z.object({
  params: z.object({
    id: z.string().min(1, 'User ID is required'),
  }),
});

// 分页查询 Schema
export const paginationQuerySchema = z.object({
  query: z.object({
    page: z.string().regex(/^\d+$/).transform(Number).optional(),
    limit: z.string().regex(/^\d+$/).transform(Number).optional(),
    sortBy: z.string().optional(),
    order: z.enum(['asc', 'desc']).optional(),
  }),
});
```

### 6.2 常用验证规则

```typescript
import { z } from 'zod';

// 字符串验证
z.string()
  .min(3, 'Minimum 3 characters')
  .max(100, 'Maximum 100 characters')
  .email('Invalid email')
  .url('Invalid URL')
  .uuid('Invalid UUID')
  .regex(/pattern/, 'Invalid format')
  .trim()
  .toLowerCase()
  .optional()
  .nullable()
  .default('default value');

// 数字验证
z.number()
  .min(0, 'Must be positive')
  .max(100, 'Maximum 100')
  .int('Must be integer')
  .positive('Must be positive')
  .negative('Must be negative')
  .multipleOf(5, 'Must be multiple of 5');

// 布尔值
z.boolean();

// 日期
z.date()
  .min(new Date('2020-01-01'), 'Date too early')
  .max(new Date(), 'Date cannot be in future');

// 枚举
z.enum(['admin', 'user', 'guest']);

// 数组
z.array(z.string())
  .min(1, 'At least one item required')
  .max(10, 'Maximum 10 items')
  .nonempty('Array cannot be empty');

// 对象
z.object({
  name: z.string(),
  age: z.number(),
});

// 联合类型
z.union([z.string(), z.number()]);

// 可选字段
z.object({
  required: z.string(),
  optional: z.string().optional(),
});

// 自定义验证
z.string().refine(
  (val) => val.length >= 8,
  { message: 'Password too short' }
);

// 转换
z.string().transform((val) => val.toLowerCase());
```

### 6.3 验证错误处理

验证失败时，会自动返回详细的错误信息：

**请求**:

```json
POST /api/users
{
  "email": "invalid-email",
  "username": "ab",
  "password": "123"
}
```

**响应**:

```json
{
  "success": false,
  "code": "VALIDATION_ERROR",
  "message": "Validation failed",
  "statusCode": 400,
  "data": {
    "details": [
      {
        "path": "body.email",
        "message": "Invalid email format"
      },
      {
        "path": "body.username",
        "message": "Username must be at least 3 characters"
      },
      {
        "path": "body.password",
        "message": "Password must be at least 8 characters"
      }
    ]
  }
}
```

---

## 7. 缓存系统

### 7.1 Redis 缓存服务

**位置**: `src/core/cache/redis.ts`

**主要方法**:

```typescript
import { cacheService } from '@/core/cache';

// 设置缓存
await cacheService.set('key', { data: 'value' }, 300); // 300 秒过期

// 获取缓存
const data = await cacheService.get('key');

// 删除缓存
await cacheService.del('key');

// 批量删除（通过模式）
await cacheService.delPattern('user:*');

// 检查键是否存在
const exists = await cacheService.exists('key');

// 设置过期时间
await cacheService.expire('key', 600);

// 获取剩余过期时间
const ttl = await cacheService.ttl('key');

// 递增
await cacheService.incr('counter');

// 递减
await cacheService.decr('counter');
```

### 7.2 缓存策略

#### 7.2.1 使用装饰器缓存

```typescript
import { Cacheable, CacheEvict } from '@/shared/decorators/cache.decorator';

export class UserRepository extends BaseRepository<typeof users> {
  // 缓存查询结果
  @Cacheable({ key: 'user:id', ttl: 600 })
  async findById(id: string) {
    return this.db.query.users.findFirst({
      where: eq(users.id, id),
    });
  }

  // 更新时清除缓存
  @CacheEvict({ key: 'user:id' })
  async update(id: string, data: any) {
    return this.db.update(users)
      .set(data)
      .where(eq(users.id, id));
  }
}
```

#### 7.2.2 手动缓存管理

```typescript
import { cacheService } from '@/core/cache';

export class UserService {
  async getUserById(id: string) {
    const cacheKey = `user:${id}`;

    // 尝试从缓存获取
    const cached = await cacheService.get(cacheKey);
    if (cached) {
      return cached;
    }

    // 从数据库查询
    const user = await userRepository.findById(id);

    // 存入缓存
    if (user) {
      await cacheService.set(cacheKey, user, 600);
    }

    return user;
  }

  async updateUser(id: string, data: any) {
    // 更新数据库
    const user = await userRepository.update(id, data);

    // 清除缓存
    await cacheService.del(`user:${id}`);

    return user;
  }
}
```

### 7.3 缓存预热

**位置**: `src/core/services/cache-warmup.service.ts`

**作用**: 应用启动时预加载常用数据到缓存。

**配置**:

```typescript
import { cacheWarmupService } from '@/core/services/cache-warmup.service';

// 在应用启动时调用
await cacheWarmupService.warmupAll();
```

**自定义预热逻辑**:

```typescript
export class CacheWarmupService {
  async warmupAll(): Promise<void> {
    await Promise.all([
      this.warmupRoles(),
      this.warmupPermissions(),
      this.warmupSettings(),
    ]);
  }

  private async warmupRoles(): Promise<void> {
    const roles = await roleRepository.findAll();
    await cacheService.set('roles:all', roles, 3600);
  }

  private async warmupPermissions(): Promise<void> {
    const permissions = await permissionRepository.findAll();
    await cacheService.set('permissions:all', permissions, 3600);
  }
}
```

### 7.4 缓存最佳实践

1. **合理设置过期时间**:
   - 静态数据（配置、权限）: 1-24 小时
   - 用户数据: 5-30 分钟
   - 会话数据: 根据 token 过期时间

2. **缓存键命名规范**:

   ```typescript
   // 推荐格式: 模块:类型:标识符
   'user:profile:123'
   'role:permissions:admin'
   'session:token:abc123'
   ```

3. **及时清除缓存**:
   - 数据更新时清除相关缓存
   - 使用 `@CacheEvict` 装饰器自动清除

4. **避免缓存穿透**:

   ```typescript
   // 缓存空结果
   const user = await userRepository.findById(id);
   await cacheService.set(cacheKey, user || null, 60);
   ```

---

## 8. 事件系统

### 8.1 事件总线

**位置**: `src/core/events/event-bus.ts`

**特点**:

- 类型安全的事件发布/订阅
- 自动错误处理
- 支持异步事件处理

### 8.2 定义事件类型

**位置**: `src/core/events/event-types.ts`

```typescript
// 定义事件数据类型
export interface UserRegisteredEvent {
  userId: string;
  email: string;
  username: string;
  timestamp: Date;
}

export interface UserLoginEvent {
  userId: string;
  email: string;
  timestamp: Date;
}

// 定义事件映射
export interface EventMap {
  'user.registered': UserRegisteredEvent;
  'user.login': UserLoginEvent;
  'user.logout': { userId: string; timestamp: Date };
  'user.updated': { userId: string; changes: any; timestamp: Date };
  'user.deleted': { userId: string; timestamp: Date };
}

export type EventName = keyof EventMap;
```

### 8.3 发布事件

```typescript
import { eventBus } from '@/core/events';

export class AuthService {
  async register(data: RegisterRequest) {
    // 创建用户
    const user = await userRepository.create(data);

    // 发布事件
    eventBus.publish('user.registered', {
      userId: user.id,
      email: user.email,
      username: user.username,
      timestamp: new Date(),
    });

    return user;
  }

  async login(data: LoginRequest) {
    // 登录逻辑...

    // 发布事件
    eventBus.publish('user.login', {
      userId: user.id,
      email: user.email,
      timestamp: new Date(),
    });

    return result;
  }
}
```

### 8.4 订阅事件

**位置**: `src/core/events/handlers/index.ts`

```typescript
import { eventBus } from '@/core/events';
import { getAppPinoLogger } from '@/core/logger/pino';

const logger = getAppPinoLogger();

export function initEventHandlers(): void {
  // 用户注册事件处理
  eventBus.subscribe('user.registered', async (data) => {
    logger.info({ userId: data.userId }, 'User registered');

    // 发送欢迎邮件
    await emailService.sendWelcomeEmail(data.email);

    // 创建默认设置
    await settingsService.createDefaultSettings(data.userId);
  });

  // 用户登录事件处理
  eventBus.subscribe('user.login', async (data) => {
    logger.info({ userId: data.userId }, 'User logged in');

    // 记录登录历史
    await loginHistoryService.record(data.userId, data.timestamp);

    // 更新最后登录时间
    await userRepository.updateLastLogin(data.userId);
  });

  // 用户登出事件处理
  eventBus.subscribe('user.logout', async (data) => {
    logger.info({ userId: data.userId }, 'User logged out');

    // 清理会话
    await sessionService.cleanup(data.userId);
  });
}
```

### 8.5 一次性事件订阅

```typescript
// 只处理一次事件
eventBus.subscribeOnce('user.registered', async (data) => {
  logger.info({ userId: data.userId }, 'First user registered!');
});
```

### 8.6 取消订阅

```typescript
// 定义处理器
const handler = async (data: UserLoginEvent) => {
  logger.info(data, 'User logged in');
};

// 订阅
eventBus.subscribe('user.login', handler);

// 取消订阅
eventBus.unsubscribe('user.login', handler);

// 取消所有订阅
eventBus.unsubscribeAll('user.login');
```

### 8.7 事件系统最佳实践

1. **事件命名规范**:

   ```typescript
   // 格式: 模块.动作
   'user.registered'
   'user.login'
   'order.created'
   'payment.completed'
   ```

2. **事件数据结构**:

   ```typescript
   // 始终包含时间戳
   interface BaseEvent {
     timestamp: Date;
   }

   // 包含必要的标识符
   interface UserEvent extends BaseEvent {
     userId: string;
   }
   ```

3. **异步处理**:
   - 事件处理器应该是异步的
   - 不要在事件处理器中抛出未捕获的错误
   - 长时间运行的任务考虑使用队列

4. **避免循环依赖**:
   - 不要在事件处理器中发布会触发自己的事件
   - 使用事件链时要小心

---

## 9. Repository 模式

### 9.1 基础 Repository

**位置**: `src/shared/repositories/base.repository.ts`

**提供的方法**:

```typescript
// 查询
findById(id: string)
findAll(options?: { includeDeleted?, limit?, offset? })
findPaginated(options: { page?, limit?, includeDeleted?, where?, orderBy? })

// 创建
create(data: any)
createMany(data: any[])

// 更新
update(id: string, data: any)

// 删除
delete(id: string)           // 硬删除
softDelete(id: string)       // 软删除
restore(id: string)          // 恢复软删除

// 统计
count(options?: { includeDeleted? })
exists(id: string)
```

### 9.2 创建自定义 Repository

```typescript
import { BaseRepository } from '@/shared/repositories/base.repository';
import { users } from '@/core/database/schema';
import { db } from '@/core/database';
import { eq, and, or } from 'drizzle-orm';

export class UserRepository extends BaseRepository<typeof users> {
  constructor() {
    super(users);
  }

  protected getTableName(): string {
    return 'users';
  }

  /**
   * 根据邮箱查找用户
   */
  async findByEmail(email: string) {
    const [user] = await db
      .select()
      .from(users)
      .where(eq(users.email, email))
      .limit(1);
    return user;
  }

  /**
   * 根据邮箱或用户名查找
   */
  async findByEmailOrUsername(email: string, username: string) {
    const [user] = await db
      .select()
      .from(users)
      .where(or(eq(users.email, email), eq(users.username, username)))
      .limit(1);
    return user;
  }

  /**
   * 查找用户及其角色和权限
   */
  async findWithRolesAndPermissions(userId: string) {
    return db.query.users.findFirst({
      where: eq(users.id, userId),
      with: {
        userRoles: {
          with: {
            role: {
              with: {
                rolePermissions: {
                  with: {
                    permission: true,
                  },
                },
              },
            },
          },
        },
      },
    });
  }

  /**
   * 更新最后登录时间
   */
  async updateLastLogin(userId: string) {
    await db
      .update(users)
      .set({ lastLoginAt: new Date() })
      .where(eq(users.id, userId));
  }

  /**
   * 激活/停用用户
   */
  async setActive(userId: string, isActive: boolean) {
    await db
      .update(users)
      .set({ isActive })
      .where(eq(users.id, userId));
  }
}

// 导出单例
export const userRepository = new UserRepository();
```

### 9.3 使用 Repository

```typescript
import { userRepository } from '../repositories/user.repository';

@Controller('/users')
export class UserController {
  @Get('/')
  async list(req: Request, res: Response) {
    // 分页查询
    const result = await userRepository.findPaginated({
      page: 1,
      limit: 20,
      includeDeleted: false,
    });

    res.json({
      success: true,
      data: result.data,
      meta: result.meta,
    });
  }

  @Get('/:id')
  async get(req: Request, res: Response) {
    const { id } = req.params;

    // 根据 ID 查询
    const user = await userRepository.findById(id);

    if (!user) {
      res.status(404).json({
        success: false,
        message: 'User not found',
      });
      return;
    }

    res.json({ success: true, data: user });
  }

  @Post('/')
  async create(req: Request, res: Response) {
    // 创建用户
    const user = await userRepository.create(req.body);
    res.status(201).json({ success: true, data: user });
  }

  @Put('/:id')
  async update(req: Request, res: Response) {
    const { id } = req.params;

    // 更新用户
    const user = await userRepository.update(id, req.body);
    res.json({ success: true, data: user });
  }

  @Delete('/:id')
  async delete(req: Request, res: Response) {
    const { id } = req.params;

    // 软删除
    await userRepository.softDelete(id);
    res.json({ success: true, message: 'User deleted' });
  }
}
```

### 9.4 Repository 最佳实践

1. **单一职责**: 每个 Repository 只负责一个表的数据访问
2. **业务逻辑分离**: Repository 只处理数据访问，业务逻辑放在 Service 层
3. **返回类型**: 明确返回类型，使用 TypeScript 类型推断
4. **错误处理**: 让错误向上传播，在 Service 或 Controller 层处理
5. **事务处理**: 复杂操作使用数据库事务

**事务示例**:

```typescript
import { db } from '@/core/database';

export class UserService {
  async createUserWithRole(userData: any, roleId: string) {
    // 使用事务
    return db.transaction(async (tx) => {
      // 创建用户
      const [user] = await tx.insert(users).values(userData);

      // 分配角色
      await tx.insert(userRoles).values({
        userId: user.id,
        roleId: roleId,
      });

      return user;
    });
  }
}
```

---

## 10. 错误处理

### 10.1 自定义异常类

**位置**: `src/shared/exceptions/index.ts`

**可用异常类**:

```typescript
import {
  AppException,
  BadRequestException,
  UnauthorizedException,
  ForbiddenException,
  NotFoundException,
  ConflictException,
  ValidationException,
  InternalServerException,
  DuplicateException,
  InvalidCredentialsException,
} from '@/shared/exceptions';
```

### 10.2 使用异常

```typescript
import { NotFoundException, BadRequestException } from '@/shared/exceptions';

@Controller('/users')
export class UserController {
  @Get('/:id')
  async get(req: Request, res: Response) {
    const { id } = req.params;

    if (!id) {
      throw new BadRequestException('User ID is required');
    }

    const user = await userRepository.findById(id);

    if (!user) {
      throw new NotFoundException('User not found');
    }

    res.json({ success: true, data: user });
  }

  @Post('/')
  async create(req: Request, res: Response) {
    const { email } = req.body;

    // 检查邮箱是否已存在
    const existing = await userRepository.findByEmail(email);
    if (existing) {
      throw new DuplicateException('Email already exists');
    }

    const user = await userRepository.create(req.body);
    res.status(201).json({ success: true, data: user });
  }
}
```

### 10.3 创建自定义异常

```typescript
import { AppException } from '@/shared/exceptions';
import { StatusCodes } from 'http-status-codes';

export class CustomException extends AppException {
  constructor(message: string, details?: any) {
    super(
      message,
      'CUSTOM_ERROR_CODE',
      StatusCodes.BAD_REQUEST,
      details
    );
  }
}

// 使用
throw new CustomException('Something went wrong', { field: 'value' });
```

### 10.4 错误响应格式

所有错误都会被统一处理并返回标准格式：

```json
{
  "success": false,
  "code": "ERROR_CODE",
  "message": "Error message",
  "statusCode": 400,
  "data": {
    "details": {} // 仅在开发环境返回
  }
}
```

**常见错误码**:

- `VALIDATION_ERROR` - 验证失败 (400)
- `UNAUTHORIZED` - 未认证 (401)
- `FORBIDDEN` - 无权限 (403)
- `NOT_FOUND` - 资源不存在 (404)
- `DUPLICATE` - 资源已存在 (409)
- `INTERNAL_SERVER_ERROR` - 服务器错误 (500)

---

## 11. 最佳实践

### 11.1 项目结构

**推荐的模块结构**:

```
src/modules/users/
├── controllers/
│   └── user.controller.ts      # 控制器
├── services/
│   └── user.service.ts         # 业务逻辑
├── repositories/
│   └── user.repository.ts      # 数据访问
├── schemas/
│   ├── index.ts
│   └── user.schema.ts          # 验证模式
├── dtos/
│   └── user.dto.ts             # 数据传输对象
└── README.md                    # 模块文档
```

### 11.2 代码组织

**分层架构**:

```
Controller (路由处理)
    ↓
Service (业务逻辑)
    ↓
Repository (数据访问)
    ↓
Database (数据库)
```

**示例**:

```typescript
// Controller - 处理 HTTP 请求
@Controller('/users')
export class UserController {
  @Post('/')
  async create(req: Request, res: Response) {
    const user = await userService.createUser(req.body);
    res.status(201).json({ success: true, data: user });
  }
}

// Service - 业务逻辑
export class UserService {
  async createUser(data: CreateUserDto) {
    // 验证业务规则
    await this.validateUserData(data);

    // 调用 Repository
    const user = await userRepository.create(data);

    // 发布事件
    eventBus.publish('user.created', { userId: user.id });

    return user;
  }
}

// Repository - 数据访问
export class UserRepository extends BaseRepository<typeof users> {
  async create(data: any) {
    return db.insert(users).values(data);
  }
}
```

### 11.3 环境变量管理

**配置文件**:

- `.env.development` - 开发环境
- `.env.production` - 生产环境
- `.env.test` - 测试环境
- `.env.example` - 示例配置

**访问环境变量**:

```typescript
import { env } from '@/core/config/env';

// 使用类型安全的环境变量
const port = env.PORT;
const dbUrl = env.DATABASE_URL;
const jwtSecret = env.JWT_SECRET;
```

**注意事项**:

- 不要提交 `.env` 文件到版本控制
- 生产环境的敏感信息使用密钥管理服务
- JWT 密钥至少 64 字符

### 11.4 日志记录

**使用 Pino Logger**:

```typescript
import { getAppPinoLogger } from '@/core/logger/pino';

const logger = getAppPinoLogger();

// 不同级别的日志（注意：上下文对象在前，消息在后）
logger.debug({ data: 'value' }, 'Debug message');
logger.info({ userId: '123' }, 'Info message');
logger.warn({ reason: 'something' }, 'Warning message');
logger.error({ err: error }, 'Error message');

// 带上下文的日志
logger.info(
  {
    requestId: req.id,
    userId: req.user?.sub,
    action: 'user.create',
  },
  'User created successfully',
);

// 创建子日志器（带固定上下文）
const childLogger = logger.child({ module: 'user-service' });
childLogger.info({ userId: '123' }, 'User operation');
```

**日志最佳实践**:

1. **使用正确的参数顺序**: `logger.info({ context }, 'message')` - 上下文对象在前，消息在后
2. **使用结构化日志**: 始终使用对象格式记录上下文信息
3. **包含请求 ID**: 用于追踪请求链路
4. **记录关键操作**: 登录、创建、更新、删除等重要操作
5. **不记录敏感信息**: 密码、token、个人隐私数据
6. **使用合适的日志级别**:
   - `debug`: 详细的调试信息（仅开发环境）
   - `info`: 重要的业务事件
   - `warn`: 警告信息，不影响功能
   - `error`: 错误信息，需要关注
7. **生产环境使用 `info` 级别**: 通过 `LOGGER_LEVEL` 环境变量配置

**错误日志记录**:

```typescript
try {
  await someOperation();
} catch (error) {
  // ✅ 正确：使用 err 字段记录错误对象
  logger.error({ err: error, userId, action: 'operation' }, 'Operation failed');
  throw error;
}
```

**更多日志功能**:

详细的日志系统使用指南请参考：`src/core/logger/pino/README.md`

### 11.5 性能优化

**数据库查询优化**:

```typescript
// ❌ 不好 - N+1 查询
const users = await userRepository.findAll();
for (const user of users) {
  user.roles = await roleRepository.findByUserId(user.id);
}

// ✅ 好 - 使用关联查询
const users = await db.query.users.findMany({
  with: {
    userRoles: {
      with: {
        role: true,
      },
    },
  },
});
```

**使用缓存**:

```typescript
// ❌ 不好 - 每次都查询数据库
const roles = await roleRepository.findAll();

// ✅ 好 - 使用缓存
@Cacheable({ key: 'roles:all', ttl: 3600 })
async findAll() {
  return db.query.roles.findMany();
}
```

**分页查询**:

```typescript
// ✅ 始终使用分页
const result = await userRepository.findPaginated({
  page: 1,
  limit: 20,
});
```

### 11.6 安全实践

**输入验证**:

```typescript
// ✅ 始终验证输入
@Validate(createUserSchema)
@Post('/users')
async create(req: Request, res: Response) {
  // 数据已验证，可以安全使用
}
```

**敏感接口限流**:

```typescript
// ✅ 为敏感接口添加限流
@RateLimit({ windowMs: 15 * 60 * 1000, max: 5 })
@Post('/auth/login')
async login(req: Request, res: Response) {}
```

**密码处理**:

```typescript
import bcrypt from 'bcryptjs';

// ✅ 加密密码
const hashedPassword = await bcrypt.hash(password, 10);

// ✅ 验证密码
const isValid = await bcrypt.compare(password, hashedPassword);

// ❌ 不要返回密码
const { password, ...userWithoutPassword } = user;
res.json({ data: userWithoutPassword });
```

**SQL 注入防护**:

```typescript
// ✅ 使用参数化查询（Drizzle ORM 自动处理）
const user = await db.query.users.findFirst({
  where: eq(users.email, email),
});

// ❌ 不要拼接 SQL
const query = `SELECT * FROM users WHERE email = '${email}'`;
```

---

## 12. 注意事项

### 12.1 装饰器使用注意事项

1. **导入顺序**:

   ```typescript
   // ✅ 正确 - reflect-metadata 必须最先导入
   import 'reflect-metadata';
   import { Controller, Get } from '@/core/router';

   // ❌ 错误
   import { Controller, Get } from '@/core/router';
   import 'reflect-metadata';
   ```

2. **装饰器顺序**:

   ```typescript
   // ✅ 推荐顺序
   @Auth()              // 1. 认证
   @RateLimit({})       // 2. 限流
   @Validate(schema)    // 3. 验证
   @Get('/')            // 4. HTTP 方法
   async handler() {}

   // 装饰器从下往上执行，所以 HTTP 方法装饰器应该最后
   ```

3. **控制器必须导出**:

   ```typescript
   // ✅ 正确
   export class UserController {}

   // ❌ 错误 - 不会被注册
   class UserController {}
   ```

4. **控制器必须在 controllers.ts 中导入**:

   ```typescript
   // src/controllers.ts
   export * from './modules/users/controllers/user.controller';
   ```

### 12.2 异步处理注意事项

1. **路由处理器必须是 async**:

   ```typescript
   // ✅ 正确
   @Get('/')
   async list(req: Request, res: Response): Promise<void> {
     const users = await userRepository.findAll();
     res.json({ data: users });
   }

   // ❌ 错误 - 不会等待异步操作
   @Get('/')
   list(req: Request, res: Response): void {
     userRepository.findAll().then(users => {
       res.json({ data: users });
     });
   }
   ```

2. **不要忘记 await**:

   ```typescript
   // ✅ 正确
   const user = await userRepository.findById(id);

   // ❌ 错误 - 返回 Promise 对象
   const user = userRepository.findById(id);
   ```

3. **错误会自动捕获**:

   ```typescript
   // ✅ 不需要 try-catch，错误会自动传递给错误处理中间件
   @Get('/:id')
   async get(req: Request, res: Response) {
     const user = await userRepository.findById(req.params.id);
     if (!user) {
       throw new NotFoundException('User not found');
     }
     res.json({ data: user });
   }
   ```

### 12.3 数据库操作注意事项

1. **软删除**:

   ```typescript
   // 表必须有 deletedAt 字段才能使用软删除
   await userRepository.softDelete(id);

   // 查询时默认过滤软删除的记录
   const users = await userRepository.findAll({ includeDeleted: false });
   ```

2. **分页查询限制**:

   ```typescript
   // limit 最大值为 100
   const result = await userRepository.findPaginated({
     page: 1,
     limit: 200, // 会被限制为 100
   });
   ```

3. **MySQL 不支持 RETURNING**:

   ```typescript
   // 创建后需要重新查询
   await db.insert(users).values(data);
   const [user] = await db.select().from(users).where(eq(users.id, data.id));
   ```

### 12.4 缓存注意事项

1. **缓存键冲突**:

   ```typescript
   // ❌ 错误 - 可能冲突
   @Cacheable({ key: 'user', includeArgs: false })
   async findById(id: string) {}

   // ✅ 正确 - 包含参数
   @Cacheable({ key: 'user:id', includeArgs: true })
   async findById(id: string) {}
   ```

2. **缓存更新**:

   ```typescript
   // ✅ 更新数据时清除缓存
   @CacheEvict({ key: 'user:id' })
   async update(id: string, data: any) {
     return db.update(users).set(data).where(eq(users.id, id));
   }
   ```

3. **缓存穿透**:

   ```typescript
   // ✅ 缓存空结果
   const user = await userRepository.findById(id);
   await cacheService.set(cacheKey, user || null, 60);
   ```

### 12.5 认证注意事项

1. **Token 格式**:

   ```typescript
   // ✅ 正确
   Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...

   // ❌ 错误
   Authorization: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
   ```

2. **Token 过期**:

   ```typescript
   // Access Token: 1 小时
   // Refresh Token: 7 天
   // 使用 refresh token 获取新的 access token
   ```

3. **登出后 Token 失效**:

   ```typescript
   // Token 会被加入黑名单
   // 即使未过期也无法使用
   await authService.logout(token);
   ```

### 12.6 验证注意事项

1. **Schema 结构**:

   ```typescript
   // ✅ 正确 - 必须包含 body/query/params
   const schema = z.object({
     body: z.object({
       email: z.string().email(),
     }),
   });

   // ❌ 错误 - 缺少包装对象
   const schema = z.object({
     email: z.string().email(),
   });
   ```

2. **可选字段**:

   ```typescript
   // ✅ 使用 optional()
   z.object({
     required: z.string(),
     optional: z.string().optional(),
   });
   ```

3. **类型转换**:

   ```typescript
   // ✅ 查询参数需要转换类型
   query: z.object({
     page: z.string().transform(Number),
     limit: z.string().transform(Number),
   });
   ```

### 12.7 事件系统注意事项

1. **事件处理器错误**:

   ```typescript
   // ✅ 错误会被自动捕获和记录
   eventBus.subscribe('user.registered', async (data) => {
     // 即使这里抛出错误，也不会影响主流程
     await emailService.sendWelcomeEmail(data.email);
   });
   ```

2. **避免循环事件**:

   ```typescript
   // ❌ 错误 - 可能导致无限循环
   eventBus.subscribe('user.updated', async (data) => {
     await userRepository.update(data.userId, {});
     eventBus.publish('user.updated', data); // 触发自己
   });
   ```

3. **事件处理顺序**:

   ```typescript
   // 事件处理器按注册顺序执行
   // 如果需要保证顺序，使用 await
   eventBus.subscribe('user.registered', async (data) => {
     await step1(data);
     await step2(data);
   });
   ```

### 12.8 性能注意事项

1. **避免 N+1 查询**:

   ```typescript
   // ❌ 错误 - N+1 查询
   const users = await userRepository.findAll();
   for (const user of users) {
     user.roles = await roleRepository.findByUserId(user.id);
   }

   // ✅ 正确 - 使用关联查询
   const users = await db.query.users.findMany({
     with: { userRoles: { with: { role: true } } },
   });
   ```

2. **大数据量查询**:

   ```typescript
   // ❌ 错误 - 可能导致内存溢出
   const allUsers = await userRepository.findAll();

   // ✅ 正确 - 使用分页
   const result = await userRepository.findPaginated({
     page: 1,
     limit: 100,
   });
   ```

3. **频繁查询使用缓存**:

   ```typescript
   // ✅ 为频繁查询的数据添加缓存
   @Cacheable({ key: 'roles:all', ttl: 3600 })
   async findAllRoles() {
     return db.query.roles.findMany();
   }
   ```

### 12.9 生产环境注意事项

1. **环境变量检查**:

   ```bash
   # 确保设置了所有必需的环境变量
   NODE_ENV=production
   DATABASE_URL=mysql://...
   REDIS_HOST=...
   JWT_SECRET=... # 至少 64 字符
   ```

2. **日志级别**:

   ```bash
   # 生产环境使用 info 级别
   LOGGER_LEVEL=info
   ```

3. **错误信息**:

   ```typescript
   // 生产环境不返回详细错误信息
   // 在 errorHandler 中自动处理
   if (env.isProduction) {
     // 不返回 stack trace 和详细信息
   }
   ```

4. **数据库连接池**:

   ```typescript
   // 配置合适的连接池大小
   // 默认配置已优化，通常不需要修改
   ```

5. **优雅关闭**:

   ```typescript
   // 应用会自动处理 SIGINT 和 SIGTERM 信号
   // 确保容器编排工具正确发送信号
   ```

---

## 附录

### A. 常用命令

```bash
# 开发
pnpm start:dev          # 启动开发服务器
pnpm build              # 构建生产版本
pnpm start:prod         # 启动生产服务器

# 数据库
pnpm db:generate        # 生成迁移文件
pnpm db:migrate         # 执行迁移
pnpm db:seed            # 填充测试数据
pnpm db:studio          # 打开数据库管理界面

# 代码质量
pnpm lint               # 代码检查并修复
pnpm type-check         # 类型检查
pnpm format             # 格式化代码

# 测试
pnpm test               # 运行测试
pnpm test:cov           # 测试覆盖率

# 工具
pnpm generate:controllers  # 生成控制器索引
pnpm generate:secrets      # 生成密钥
```

### B. 快速参考

#### 装饰器速查

| 装饰器 | 作用 | 示例 |
|--------|------|------|
| `@Controller(prefix)` | 定义控制器 | `@Controller('/users')` |
| `@Get(path)` | GET 路由 | `@Get('/')` |
| `@Post(path)` | POST 路由 | `@Post('/')` |
| `@Put(path)` | PUT 路由 | `@Put('/:id')` |
| `@Delete(path)` | DELETE 路由 | `@Delete('/:id')` |
| `@Auth()` | JWT 认证 | `@Auth()` |
| `@Validate(schema)` | 数据验证 | `@Validate(userSchema)` |
| `@RateLimit(options)` | 限流 | `@RateLimit({ max: 5 })` |
| `@Cacheable(options)` | 缓存结果 | `@Cacheable({ key: 'user' })` |
| `@CacheEvict(options)` | 清除缓存 | `@CacheEvict({ key: 'user' })` |

#### HTTP 状态码

| 状态码 | 说明 | 使用场景 |
|--------|------|----------|
| 200 | OK | 成功 |
| 201 | Created | 创建成功 |
| 204 | No Content | 删除成功 |
| 400 | Bad Request | 请求参数错误 |
| 401 | Unauthorized | 未认证 |
| 403 | Forbidden | 无权限 |
| 404 | Not Found | 资源不存在 |
| 409 | Conflict | 资源冲突 |
| 429 | Too Many Requests | 请求过多 |
| 500 | Internal Server Error | 服务器错误 |

#### 响应格式

**成功响应**:

```json
{
  "success": true,
  "data": {},
  "meta": {}
}
```

**错误响应**:

```json
{
  "success": false,
  "code": "ERROR_CODE",
  "message": "Error message",
  "statusCode": 400,
  "data": {
    "details": []
  }
}
```

### C. 故障排查

#### 1. 路由未注册

**问题**: 访问路由返回 404

**解决方案**:

- 检查控制器是否在 `src/controllers.ts` 中导入
- 检查控制器类是否使用 `export` 导出
- 检查是否使用了 `@Controller` 装饰器
- 重启开发服务器

#### 2. 认证失败

**问题**: 返回 401 Unauthorized

**解决方案**:

- 检查 Token 格式是否正确（`Bearer <token>`）
- 检查 Token 是否过期
- 检查 JWT_SECRET 是否正确
- 检查 Token 是否在黑名单中

#### 3. 验证失败

**问题**: 返回 400 Validation Error

**解决方案**:

- 检查请求数据格式是否正确
- 检查 Schema 定义是否包含 `body`/`query`/`params`
- 查看错误详情中的具体字段错误

#### 4. 数据库连接失败

**问题**: 应用启动失败

**解决方案**:

- 检查 `DATABASE_URL` 是否正确
- 检查数据库服务是否运行
- 检查数据库用户权限
- 检查网络连接

#### 5. Redis 连接失败

**问题**: 缓存操作失败

**解决方案**:

- 检查 `REDIS_HOST` 和 `REDIS_PORT` 是否正确
- 检查 Redis 服务是否运行
- 检查 Redis 密码（如果有）
- 检查网络连接

---

## 总结

本操作手册涵盖了项目的核心功能和使用方法：

1. **装饰器系统** - 简化路由定义和功能配置
2. **路由系统** - 自动注册和管理路由
3. **中间件系统** - 请求处理流程和安全保护
4. **认证授权** - JWT 认证和权限控制
5. **数据验证** - Zod schema 验证
6. **缓存系统** - Redis 缓存和装饰器
7. **事件系统** - 类型安全的事件总线
8. **Repository 模式** - 数据访问层抽象
9. **错误处理** - 统一的错误处理机制
10. **最佳实践** - 代码组织和性能优化
11. **注意事项** - 常见问题和解决方案

遵循本手册的指导，可以高效地开发和维护项目。如有疑问，请参考项目文档或联系开发团队。

---

**文档版本**: 1.0
**最后更新**: 2025-12-16
**维护者**: 开发团队
